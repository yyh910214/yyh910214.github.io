# JAVA8
## 스트림
### 스트림 연산이란?
```java
int count = 0;
for(String w : words)  {
  if( w.length() > 12) count++;
}
---------------------------------

long count = words.stream().filter(w -> w.length() > 12).count();
```
스트림을 사용하면 위의 부분을 아래와 같이 처리할 수 있다.

#### ** 스트림의 특징**
1. 스트림은 요소들을 보관하지 않는다. 요소들은 하부 컬렉션에 보관.
2. 스트림은 원본을 변경하지 않는다.
3. 스트림 연산은 가능하면 lazy처리된다(결과가 필요하기 전에 실행되지 않음)
4. 병렬 연산을 처리하기 쉽다.
```java
long count = words.parallerStream().filter(w->w.length() > 12).count();
```
와 같이 적용하여 병렬 연산을 적용할 수 있다.
5. **스트림은 LAZY 연산**을 적용하기 때문에 스트림에서 호출된 순서로 실행되지 않는다. 위 예시의 경우 count가 호출되기 전에는 아무일도 일어나지 않다가 count가 호출되고 나서 filter가 실행되면서 12보다 긴 문자열을 찾는다.

### 스트림 사용법
#### 생성하기
```java
Stream<String> words = Stream.of(Array);
Stream<String> words = Stream.of("a","b","c"); // 가변 인자
Stream<String> words = Stream.of(Array, int from, int to); // 배열 범위
Stream<String> words = Stream.empty();
Stream<String> words = Stream.generate(()->"ECHO");
Stream<Double> rand = Stream.generate(Math::random); //무한 랜덤 숫자
Stream<Integer> integers = Stream.iterate(0, n->n.add(1)) // 무한 iterate스트림
```
이와 같이 생성할 수 있으며, generate의 경우 인자 없는 메서드를 이용한다.(실제로는 Supplier<T>인터페이스의 객체)
iterate의 경우 실제로 UnaryOperator<T>의 객체를 함수로 받고, 시드로 부터 시작해서 계속 계산한다.
또한, 자바8의 다양한 클래스는 메서드들이 추가되었다.
ex) Pattern.splitAsStream, Files.lines
Files.lines같은 경우는 리턴받은 스트림이 close를 호출할 경우 하부의 파일도 자동으로 닫아준다.

#### 메서드
filter, map, flatMap 세 종류의 메서드가 있다.
filter의 경우 Predicate<T>를 받는다(인자 하나를 받아서 boolean을 리턴)
```java
Stream<String> longWords = words.filter(w->w.length() > 2);
```
map의 경우 값을 하나 받아서 새로운 값을 리턴한다.
```java
Stream<Character> firstChars = words.map(s->s.charAt(0));
```
flatMap을 통해서 MONAD 이론의 개념을 펼칠 수 있다.(모나드이론 ?)
```java
public static Stream<Charater> characterStream(String s)  {
  List<Character> result = new ArrayList<>();
  for( char c : s.toCharArray()) result.add(c);
  return result.stream();
}

Stream<Stream<Character>> result = words.map(w->characterStream(w)); // 이 경우 스트림의 스트림으로 나와 활용하기 어렵다.
Stream<Character> result = words.flatMap(w->characterStream(w));
```

#### 서브스트림
```java
// 0~99번째의 숫자 스트림
Stream<Double> randoms = Stream.generate(Math::random).limit(100);
// 100번째 이후의 숫자 스트림
Stream<Double> randoms = Stream.generate(Math::random).skip(100);
// Stream concat을 통해 두 스트림을 합칠 수 있다.
// 단 첫번째 스트림이 무한이면 불가능
Stream<Character> combined = Stream.concat(characterStream("HELLO"),characterStream("WORLD"));
```
