# JAVA8
## 1. 람다
자바8로 넘어오면서 가장 많이 눈에 띄는 기능으로는 람다가 있다.
보통 구현해야 할 추상 메서드를 하나만 가지고 있는 인터페이스가 자바에는 많이 존재하는데 이를 람다 표현식을 이용해서 표현할 수 있다.

GUI나 안드로이드를 개발하다가 자주 마주하게 되는 EventListener나 Integer의 Compare와 같은 메서드가 대표적이다.

### 함수형 인터페이스

### 메서드 레퍼런스
System.out::println은 x->System.out.println(x) 람다식과 의미가 같은 메서드 레퍼런스이다.
특히 super::method의 경우 주어진 클래스를 대상으로 상위 클래스의 메서드를 호출할 수 있다.

### 생성자 레퍼런스
Member::new 는 Member의 생성자를 의미하고 문맥에 따라 어떤 생성자를 호출할지 결정한다.
문맥상 String 인자를 하나만 받으면 Member(String)을 호출할 수 있게 된다.
비슷한 예시로 `int[]::new`의 경우 `x -> new int[x]`를 나타내고, 이를 이용해서 `Member[] members = stream.toArray(Member[]::new)` 와 같이 Member의 배열을 만들어낼 수 있다.

### 변수의 유효범위
람다 표현식에서 해당 표현식을 감싸고 있는 메서드나 클래스의 변수에 접근 하고 싶을 경우 람다 표현식의 자유변수의 값을 캡쳐해 내부적으로 사용할 수 있다.
```java
public static void repeatMessage(String text, int count) {
  Runnable r = () - > {
    for (int i = 0; i < count; ++i)  {
      System.out.println(text);
    }
  };
  new Thread(r).start();
}
```
이런 메서드가 있다고 가정할 경우 JAVA도 클로저를 지원하여 text와 count 변수를 쓸 수 있다. 그러나 내부에서는 final로 인식하여 값 변경은 불가능 하다.

```java
public static void repeatMessage(String text, int count) {
  Runnable r = () - > {
    for (int i = 0; i < count; ++i)  {
      count++;
      System.out.println(text);
    }
  };
  new Thread(r).start();
}
```
위와 같이 count 변수의 값을 직접 변경하려면 불가능하다.
여러개의 쓰레드에서 count값을 변경한다고 가정했을 경우 위험한 상태가 된다.
하지만 만약 count가 int가 아니라 객체였다면 얘기가 달라질 수 있다.
```java
public static void repeatMessage(String text, ArrayList list) {
  Runnable r = () - > {
    list.add(1);
  };
  new Thread(r).start();
}
```
이와 같이 list에 대한 레퍼런스를 변경할 수는 없지만, list 객체 내부의 내용을 변경하는 것은 가능하기 때문이다.

또한, 람다표현식의 내용은 **중첩 블록과 동일한 유효범위**를 가진다. 따라서
```java
String first = "first";
Comparator<String> comp = (first, second) ->
  Integer.compare(first.length(), second.length());
```
는 이미 위에 first가 정의되어 있기 때문에 오류가 된다.

**또한 this와 super또한 람다를 생성하는 메서드의 this를 참조한다.**

### Default Interface
기존에는 interface의 메서드에 대용을 구현하는 것이 허용되지 않았지만, JAVA8에서는 default키워드를 이용하여 할 수있다.
```java
interface Member  {
  long getId();
  default String getName() { return "YYH";}
}
```
하지만 이렇게 할 경우 diamond inheritance의 경우를 생각해볼 수 있는데, 이 경우 다음 규칙이 적용된다.
1. 슈퍼클래스와 인터페이스가 같은 메서드를 구현하고 있을 경우 슈퍼클래스의 내용을 적용한다.
2. 두개의 슈퍼 인터페이스가 같은 메서드를 제공(두 인터페이스중 하나만 디폴트여도 문제가 된다)하고 있을 경우 컴파일에러를 보고한다.

** 인터페이스가 STATIC메서드를 가질 수 있다**는 것도 JAVA8의 중요한 특징이다.
EX) Comparator의 comparing
## 2. 스트림
### 스트림 연산이란?
```java
int count = 0;
for(String w : words)  {
  if( w.length() > 12) count++;
}
---------------------------------

long count = words.stream().filter(w -> w.length() > 12).count();
```
스트림을 사용하면 위의 부분을 아래와 같이 처리할 수 있다.

#### ** 스트림의 특징**
1. 스트림은 요소들을 보관하지 않는다. 요소들은 하부 컬렉션에 보관.
2. 스트림은 원본을 변경하지 않는다.
3. 스트림 연산은 가능하면 lazy처리된다(결과가 필요하기 전에 실행되지 않음)
4. 병렬 연산을 처리하기 쉽다.
```java
long count = words.parallerStream().filter(w->w.length() > 12).count();
```
와 같이 적용하여 병렬 연산을 적용할 수 있다.
5. **스트림은 LAZY 연산**을 적용하기 때문에 스트림에서 호출된 순서로 실행되지 않는다. 위 예시의 경우 count가 호출되기 전에는 아무일도 일어나지 않다가 count가 호출되고 나서 filter가 실행되면서 12보다 긴 문자열을 찾는다.

### 스트림 사용법
#### 생성하기
```java
Stream<String> words = Stream.of(Array);
Stream<String> words = Stream.of("a","b","c"); // 가변 인자
Stream<String> words = Stream.of(Array, int from, int to); // 배열 범위
Stream<String> words = Stream.empty();
Stream<String> words = Stream.generate(()->"ECHO");
Stream<Double> rand = Stream.generate(Math::random); //무한 랜덤 숫자
Stream<Integer> integers = Stream.iterate(0, n->n.add(1)) // 무한 iterate스트림
```
이와 같이 생성할 수 있으며, generate의 경우 인자 없는 메서드를 이용한다.(실제로는 Supplier<T>인터페이스의 객체)
iterate의 경우 실제로 UnaryOperator<T>의 객체를 함수로 받고, 시드로 부터 시작해서 계속 계산한다.
또한, 자바8의 다양한 클래스는 메서드들이 추가되었다.
ex) Pattern.splitAsStream, Files.lines
Files.lines같은 경우는 리턴받은 스트림이 close를 호출할 경우 하부의 파일도 자동으로 닫아준다.

#### 메서드
filter, map, flatMap 세 종류의 메서드가 있다.
filter의 경우 Predicate<T>를 받는다(인자 하나를 받아서 boolean을 리턴)
```java
Stream<String> longWords = words.filter(w->w.length() > 2);
```
map의 경우 값을 하나 받아서 새로운 값을 리턴한다.
```java
Stream<Character> firstChars = words.map(s->s.charAt(0));
```
flatMap을 통해서 MONAD 이론의 개념을 펼칠 수 있다.(모나드이론 ?)
```java
public static Stream<Charater> characterStream(String s)  {
  List<Character> result = new ArrayList<>();
  for( char c : s.toCharArray()) result.add(c);
  return result.stream();
}

Stream<Stream<Character>> result = words.map(w->characterStream(w)); // 이 경우 스트림의 스트림으로 나와 활용하기 어렵다.
Stream<Character> result = words.flatMap(w->characterStream(w));
```

#### 서브스트림
```java
// 0~99번째의 숫자 스트림
Stream<Double> randoms = Stream.generate(Math::random).limit(100);
// 100번째 이후의 숫자 스트림
Stream<Double> randoms = Stream.generate(Math::random).skip(100);
// Stream concat을 통해 두 스트림을 합칠 수 있다.
// 단 첫번째 스트림이 무한이면 불가능
Stream<Character> combined = Stream.concat(characterStream("HELLO"),characterStream("WORLD"));
```
